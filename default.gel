module default {
    type Address {
        state: str;
        city: str;
        district: str;
        street: str;
        number: int16;
        complement: str;
        postal: str;
    }

    type Contact {
        number: str;
        contact: str;
        complement: str;
    }

    type Auditable {
        timestamp: datetime {
            default := datetime_of_statement();
        };
        object_id: uuid;
        user: uuid;
        action: str;
        details: json;
    }

     # Person or Organization
     type Entity {
        user: User;
        title: str;
        timestamp: datetime {
            default := datetime_of_statement();
        };
        required email: str {
            delegated constraint exclusive;
        };
        type_entity: str;
        govt_id: str;
        template_model: str;
        name: str;
        sex: str;
        relationship_status: str;
        details: str;
        birth: cal::local_date;
        multi phone : Contact{
            on source delete delete target;
            on target delete allow;
        };
        multi address : Address{
            on source delete delete target;
            on target delete allow;
        };
        custom_fields: json;

        trigger log_update after update for each when ( <json>__old__ {*} != <json>__new__ {*}
        ) do (
            insert Auditable {
                user := __old__.user.id,
                object_id := __old__.id,
                action := "update",
                details := to_json(
                    '{' ++
                    '"before": ' ++ <str><json>__old__{*} ++ ',' ++
                    '"after": ' ++ <str><json>__new__{*} ++
                    '}'
                ),
            }
        );

        trigger log_insert after insert for each do (
            insert Auditable {
                user := __new__.user.id,
                object_id := __new__.id,
                action := "insert",
                details := <json>__new__{*}
            }
        );

        trigger log_delete after delete for each do (
            insert Auditable {
                user := __old__.user.id,
                object_id := __old__.id,
                action := "delete",
                details := <json>__old__{*}
            }
        );
    }

    type User {
        required name: str;
        required email: str {
            constraint exclusive;
        };
        required password: str;
        isActive: bool{
            default := false;
        };
        lastActiveDate: datetime;
        multi account: BankAccount {
            on target delete allow;
            on source delete delete target;

            constraint exclusive
        };

        multi movement:= .<user[is Movement];
        multi entity := .<user[is Entity];
        multi record := .<user[is Record];
        multi event := .<user[is Scheduler];
        multi templates : Templates {
            on target delete allow;
            on source delete delete target;
        };

        # Trigger log update when password changes
        trigger log_update after update for each when (
            __old__.password != __new__.password
        ) do (
            insert Auditable {
                user := __old__.id,
                object_id := __old__.id,
                action := "update",
                details := to_json('{' ++ '"Action": "Password Updated"'++'}')
            }
        );

        trigger log_insert after insert for each do (
            insert Auditable {
                user := __new__.id,
                object_id := __new__.id,
                action := "insert",
                details := <json>__new__ {*}
            }
        );

        trigger link_delete after delete for each do (
            delete (select User.<user)
        );
    }

    # Service or Action
    type Record {
        user: User;
        title: str;
        id_Service: str;
        status: bool;
        value: float32;
        template_model: str;
        details: str;
        custom_fields: json;
        multi entity: Entity {
            on source delete delete target;

            # Target can only be linked once creating a one to many relationship
            constraint exclusive;
        };
        multi event: Scheduler {
            on source delete delete target;
            on target delete allow;

            # Target can only be linked once creating a one to many relationship
            constraint exclusive;
        };
        single movement: Movement {
            on source delete delete target;
            on target delete allow;
        };

        trigger log_update after update for each when (
            <json>__old__{*} != <json>__new__{*}
        ) do (
            insert Auditable {
                user := __old__.user.id,
                object_id := __old__.id,
                action := "update",
                details := to_json(
                    '{' ++
                    '"before": ' ++ <str><json>__old__{*} ++ ',' ++
                    '"after": ' ++ <str><json>__new__{*} ++
                    '}'
                )
            }
        );

        trigger log_insert after insert for each do (
            insert Auditable {
                user := __new__.user.id,
                object_id := __new__.id,
                action := "insert",
                details := <json>__new__{*}
            }
        );

        trigger log_delete after delete for each do (
            insert Auditable {
                user := __old__.user.id,
                object_id := __old__.id,
                action := "delete",
                details := <json>__old__{*},
            }
        );
    }

    type Templates {
        name: str;
        category: str;
        fields: json;
    }

     type Scheduler {
        user: User;
        tag_type: str;
        name: str;
        status: bool {
            default:= false;
        };
        end_date: cal::local_date;
        effective_date: cal::local_date;
        beginning_time: cal::local_time;
        end_time: cal::local_time;
        details: str;
    }

    type MonthlySumary {
        year: int16;
        month: int16;
        expense: float64;
        income: float64;
    }

    type BankAccount {
        bankName: str;
        agency: str;
        accountNumber: str;
        balance: float64 {
            constraint min_value(0);
        };
        accountType: str;
        multi sumary : MonthlySumary {
            on source delete delete target;
            constraint exclusive;
        };
    }

    type Movement {
        user: User;
        name: str;
        value: float32;
        installment: int16;
        cycle: str;
        effective: bool {
            default := false;
        };
        category: str;
        subcategory: str;
        single account: BankAccount;
        multi payment: Payment{
            on source delete delete target;
            on target delete allow;
        };

        trigger log_update after update for each when (
            <json>__old__ {*} != <json>__new__ {*}
        ) do (
            insert Auditable {
                user := __old__.user.id,
                object_id := __old__.id,
                action := "update",
               details := to_json(
                    '{' ++
                    '"before": ' ++ <str><json>__old__{*} ++ ',' ++
                    '"after": ' ++ <str><json>__new__{*} ++
                    '}'
                )
            }
        );

        trigger log_insert after insert for each do (
            insert Auditable {
                user := __new__.user.id,
                object_id := __new__.id,
                action := "insert",
                details := <json>__new__ {*}
            }
        );

        trigger log_delete after delete for each do (
            insert Auditable {
                user := __old__.user.id,
                object_id := __old__.id,
                action := "delete",
                details := <json>__old__ {*}
            }
        );
    }

    type Payment {
        user: User;
        movement: Movement;
        value: float32;
        paymentDate: cal::local_date;
        isDue: cal::local_date;
        status: bool{
            default:= false;
        };
        part: int16;
        single event: Scheduler {
            on source delete delete target;
        }

        # Updates balance on movement.account.balance when insert Payment.
        trigger update_balance_on_insert after insert for each when (
            __new__.status = true
        ) do (
            update BankAccount filter .id = __new__.movement.account.id set {
                balance := .balance + __new__.value
            }
        );

        # Updates balance on movement.account.balance when delete Payment.
        trigger update_balance_on_delete after delete for each when (
            __old__.status = true
        ) do (
            update BankAccount filter .id = __old__.movement.account.id set {
                balance := .balance - __old__.value
            }
        );

        trigger balance_value_changed after update for each when (
            __old__.status = true and __old__.value != __new__.value
        ) do (
            update BankAccount filter .id = __old__.movement.account.id set {
                balance := .balance - __old__.value + __new__.value
            }
        );

        trigger balance_account_changed after update for each when (
            __old__.status = true and __old__.movement.account != __new__.movement.account
        ) do (
            with
            subtract_old := (
                update BankAccount filter .id = __old__.movement.account.id set {
                    balance := .balance - __old__.value
                }
            ),
            add_new := (
                update BankAccount filter .id = __new__.movement.account.id set {
                    balance := .balance + __new__.value
                }
            )
            select (subtract_old, add_new)
        );

        trigger balance_status_toggled after update for each when (
            __old__.status != __new__.status
        ) do (
            update BankAccount filter .id = __new__.movement.account.id set {
                balance := .balance + (
                    (1 if __new__.status else -1) * __new__.value
                )
            }
        );

        # Updates Movement.effective to TRUE if all instances associated to Movement.payment has status equal to TRUE. The query is executed on each insert or update on Payment.
        trigger update_status_action after update, insert for each when (__new__.status = true) do (
            with movement_linked:= (select Movement filter .id = __new__.movement.id),
                not_effective:= (select Payment filter .movement = __new__.movement and .status = false),
                update Movement filter .id = movement_linked.id set {effective:= (select not exists not_effective)}
        );

        # Insert Payment.event.
        trigger create_event after insert for each do (
            with data := ( insert Scheduler {
                user:= __new__.user,
                name:= __new__.movement.name,
                status:= __new__.status,
                end_date:= __new__.isDue,
                effective_date:= __new__.paymentDate,
                tag_type:= "Movement",
            }
            )
            update Payment filter .id = __new__.id set {
                event := data
            }
        );

        # Updates Payment.event.
        trigger update_event after update for each do (
            update __old__.event set {
                name:= __new__.movement.name,
                status:= __new__.status,
                end_date:= __new__.isDue,
                effective_date:= __new__.paymentDate,
            }
        )
    }

    #Count Number of institutions or individuals from user
    function EntityNum (user_id: str) -> int64
    using (
        with entities := (select User filter .id = <uuid>user_id).entity
        select count(entities)
    );

    # Count Number of Services or Actions from user
    function RecordNum (user_id: str) -> int64
    using (
        with recorded := (select User filter .id = <uuid>user_id).record
        select count(recorded)
    );

    # Count Number of Transactions from user
    function MovementNum (user_id: str) -> int64
    using (
        with movements := (select User filter .id = <uuid>user_id).movement
        select count(movements)
    );
        # Count Number of Events from user
    function SchedulerNum (user_id: str) -> int64
    using (
        with events := (select User filter .id = <uuid>user_id).event
        select count(events)
    );

    # Return total balance from user
    function balanceTotal (user_id: str) -> float64
    using (
        with total := (select User filter .id = <uuid>user_id).account
        select sum(total.balance)
    );

}
